程序出错该返回啥？NULL、异常、错误码、空对象？
    
    在正常情况下、函数返回数据的类型非常明确，但是，在异常情况下，函数返回的数据类型却非常灵活。
    有多种选择。函数在异常情况下可以返回错误码，NULL值，特殊值(比如-1)、空对象(比如空字符串，空集合等)。
    
    函数是代码的一个非常重要的编写单元，而函数的异常处理，又是我们在编写函数的时候，时刻都要考虑的。
    所以，今天我们就聊一聊，如何设计函数在异常情况下的返回数据类型。

函数出错应该返回啥:

    函数出错返回数据类型，分别时: 错误码, NULL值, 空对象, 异常对象。
    
    1、返回错误码:
        在 C 语言中，错误码的返回方式有两种：一种是直接占用函数的返回值，函数正常执行的返回值放到出参中；
        另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。
        实际上，如果你熟悉的编程语言中有异常这种语法机制，那就尽量不要使用错误码。
        异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息（exception 中可以有 message、stack trace 等信息）等。    
    
    2、返回 NULL 值:
        
        在多数编程语言中，我们用 NULL 来表示“不存在”这种语义。不过，网上很多人不建议函数返回 NULL 值，
        认为这是一种不好的设计思路，主要的理由有以下两个。
            
            如果某个函数有可能返回 NULL 值，我们在使用它的时候，忘记了做 NULL 值判断，就有可能会抛出空指针异常（Null Pointer Exception，缩写为 NPE）。
            
            如果我们定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值判断逻辑，一方面写起来比较繁琐，
            另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。    
            
        
            public class UserService {
              private UserRepo userRepo; // 依赖注入
              
              public User getUser(String telephone) {
                // 如果用户不存在，则返回null
                return null;
              }
            }
            
            // 使用函数getUser()
            User user = userService.getUser("18917718965");
            if (user != null) { // 做NULL值判断，否则有可能会报NPE
              String email = user.getEmail();
              if (email != null) { // 做NULL值判断，否则有可能会报NPE
                String escapedEmail = email.replaceAll("@", "#");
              }
            }
            
        我个人觉得，尽管返回 NULL 值有诸多弊端，但对于以 get、find、select、search、query 等单词开头的查找函数来说，
        数据不存在，并非一种异常情况，这是一种正常行为。所以，返回代表不存在语义的 NULL 值比返回异常更加合理。
        
        不过，话说回来，刚刚讲的这个理由，也并不是特别有说服力。对于查找数据不存在的情况，
        函数到底是该用 NULL 值还是异常，有一个比较重要的参考标准是，看项目中的其他类似查找函数都是如何定义的，
        只要整个项目遵从统一的约定即可。如果项目从零开始开发，并没有统一约定和可以参考的代码，
        那你选择两者中的任何一种都可以。你只需要在函数定义的地方注释清楚，让调用者清晰地知道数据不存在的时候会返回什么就可以了。
        
        再补充说明一点，对于查找函数来说，除了返回数据对象之外，有的还会返回下标位置，比如 Java 中的 indexOf() 函数，
        用来实现在某个字符串中查找另一个子串第一次出现的位置。函数的返回值类型为基本类型 int。这个时候，
        我们就无法用 NULL 值来表示不存在的情况了。对于这种情况，我们有两种处理思路，
        一种是返回 NotFoundException，一种是返回一个特殊值，比如 -1。不过，显然 -1 更加合理，
        理由也是同样的，也就是说“没有查找到”是一种正常而非异常的行为。
        
    3、 返回空对象:
    
        返回 NULL 值有各种弊端。应对这个问题有一个比较经典的策略，那就是应用空对象设计模式（Null Object Design Pattern）。
        关于这个设计模式，我们在后面章节会详细讲，现在就不展开来讲解了。
        不过，我们今天来讲两种比较简单、比较特殊的空对象，那就是空字符串和空集合。
        
        当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。
        这样，我们在使用函数的时候，就可以不用做 NULL 值判断。        
        
        
        // 使用空集合替代NULL
        public class UserService {
          private UserRepo userRepo; // 依赖注入
          
          public List<User> getUsers(String telephonePrefix) {
           // 没有查找到数据
            return Collections.emptyList();
          }
        }
        
        // getUsers使用示例
        List<User> users = userService.getUsers("189");
        for (User user : users) { //这里不需要做NULL值判断
          // ...
        }
        
        // 使用空字符串替代NULL
        public String retrieveUppercaseLetters(String text) {
          // 如果text中没有大写字母，返回空字符串，而非NULL值
          return "";
        }
        // retrieveUppercaseLetters()使用举例
        String uppercaseLetters = retrieveUppercaseLetters("wangzheng");
        int length = uppercaseLetters.length();// 不需要做NULL值判断 
        System.out.println("Contains " + length + " upper case letters.");
        
    4、抛出异常对象:
        
        尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式就是抛出异常。
        异常可以携带更多的错误信息，比如函数调用栈信息。
        除此之外，异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好。 
        
        对于运行时异常，我们在编写代码的时候，可以不用主动去 try-catch，编译器在编译代码的时候，
        并不会检查代码是否有对运行时异常做了处理。
        相反，对于编译时异常，我们在编写代码的时候，需要主动去 try-catch 或者在函数定义中声明，否则编译就会报错。
        所以，运行时异常也叫作非受检异常（Unchecked Exception），编译时异常也叫作受检异常（Checked Exception）。  
        
        实际上，Java 支持的受检异常一直被人诟病，很多人主张所有的异常情况都应该使用非受检异常。
        支持这种观点的理由主要有以下三个。
            受检异常需要显式地在函数定义中声明。如果函数会抛出很多受检异常，那函数的定义就会非常冗长，
            这就会影响代码的可读性，使用起来也不方便。
            
            编译器强制我们必须显示地捕获所有的受检异常，代码实现会比较繁琐。而非受检异常正好相反，
            我们不需要在定义中显示声明，并且是否需要捕获处理，也可以自由决定。
            
            受检异常的使用违反开闭原则。如果我们给某个函数新增一个受检异常，
            这个函数所在的函数调用链上的所有位于其之上的函数都需要做相应的代码修改，
            直到调用链中的某个函数将这个新增的异常 try-catch 处理掉为止。
            而新增非受检异常可以不改动调用链上的代码。我们可以灵活地选择在某个函数中集中处理，
            比如在 Spring 中的 AOP 切面中集中处理异常。
            
        不过，非受检异常也有弊端，它的优点其实也正是它的缺点。从刚刚的表述中，我们可以看出，
        非受检异常使用起来更加灵活，怎么处理的主动权这里就交给了程序员。
        我们前面也讲到，过于灵活会带来不可控，非受检异常不需要显式地在函数定义中声明，那我们在使用函数的时候，
        就需要查看代码才能知道具体会抛出哪些异常。非受检异常不需要强制捕获处理，
        那程序员就有可能漏掉一些本应该捕获处理的异常。对于应该用受检异常还是非受检异常，
        网上的争论有很多，但并没有一个非常强有力的理由能够说明一个就一定比另一个更好。
        所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。
        
如何处理函数抛出的异常？总结一下，一般有下面三种处理方法。
    
    1、直接吞掉:
        
        public void func1() throws Exception1 {
          // ...
        }
        
        public void func2() {
          //...
          try {
            func1();
          } catch(Exception1 e) {
            log.warn("...", e); //吐掉：try-catch打印日志
          }
          //...
        }
    
    2、 原封不动地 re-throw。
       
        public void func1() throws Exception1 {
          // ...
        }
        
        
        public void func2() throws Exception1 {//原封不动的re-throw Exception1
          //...
          func1();
          //...
        }     
    
    3、包装成新的异常 re-throw。
    
        public void func1() throws Exception1 {
          // ...
        }
        
        public void func2() throws Exception2 {
          //...
          try {
            func1();
          } catch(Exception1 e) {
           throw new Exception2("...", e); // wrap成新的Exception2然后re-throw
          }
          //...
        }
    
    当我们面对函数抛出异常的时候，应该选择上面的哪种处理方式呢？我总结了下面三个参考原则：
    (1) 如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，
        我们完全可以在 func2() 内将 func1() 抛出的异常吞掉；
    (2) 如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，
        我们可以选择直接将 func1 抛出的异常 re-throw；
    (3) 如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，
        我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw。
        
    总之，是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。
    是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。
    如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出。
    
  