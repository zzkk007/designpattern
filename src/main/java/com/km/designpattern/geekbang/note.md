0、代码质量评判标准
      
      常用的几个标准：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。
      其中，可维护性、可读性、可扩展性最重要的三个标准。
      
   如何写出高质量的代码：
   
      写出高质量的代码需要掌握更加细化、更加落地的编程方法论,
      包含面向对象设计思想、设计原则、设计模式、编程规范、重构技巧等。       

1、面向对象:

    （1）封装、抽象、继承、多态
        
        封装：
            封装叫做信息隐藏或者数据访问保护，类通过暴露有限的访问接口，
            授权外部仅能通过类提供的方法来访问内部信息或数据。它需要编程语言
            提供权限访问控制语法来支持。java：private、protected、piblic。
            封装特性存在的意义，一方面是保护数据不被随意修改，提供代码的可维护性；
            另一方面是仅暴露有限的必要接口，提供类的易用性。
        
        抽象：
            如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，
            让使用者只需要关心方法提供了那些功能，不需要知道这些功能是如何实现的。
            抽象可以通过接口类或者抽象类来实现。
            抽象存在的意义，一方面是修改实现不需要改变定义；
            另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
        
        继承：
            继承用来表示类之间的 is-a 关。
            
        多态：
            多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。
            多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、
            duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、
            设计原则、编程技巧的代码实现基础。
                
    （2）面向对象编程 VS 面向过程编程：
        
        面向对象编程相比面向过程编程的优势主要有三个：
            a. 程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。
               面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
               
            b. 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。
               利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
               
            c. 从编程语言跟机器打交道方式的演进规律中，我们可以总结出：
                面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。

    （3）面向对象分析、设计、编程
        
        OOA: 面向对象分析，搞清楚做什么，产出是详细的需求描述，
        OOD: 面向对象设计，高清楚怎么做，产出是类。
        OOP: 面向对象编程，讲分析和设计的结果编译成代码的过程。
        
        面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。
        至于到底选择哪种划分方法，判定的标准是让代码尽量的满足“松耦合、高内聚”、
        单一职责、对扩展开放，对修改关闭。尽量地做到代码可复用、易读、易扩展、易维护。
        
        我们将需求描述转化为具体的类设计，这个环节可以拆分下面四部分：
            a. 划分职责进而识别出有那些类
                根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看那些
                功能点职责相近，操作同样的属性，可否归为同一个类。
                
            b. 定义类及其属性和方法：
              
                我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，
                把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。
            
            c. 定义类与类之间的交互关系
                
                泛化：
                    泛化（Generalization）可以简单理解为继承关系。
                    
                    public class A { ... }
                    public class B extends A { ... }
                    
                实现：
                    
                    实现（Realization）一般是指接口和实现类之间的关系。
                    
                    public interface A {...}
                    public class B implements A { ... }
                       
                组合：
                    组合、关联
                    组合（Composition）也是一种包含关系。A 类对象包含 B 类对象，
                    B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，
                    比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样
                    
                    public class A {
                      private B b;
                      public A() {
                        this.b = new B();
                      }
                    }
                    
                    关联（Association）是一种非常弱的关系，包含聚合、组合两种关系。
                    具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。
                    具体到 Java 代码就是下面这样：
                    
                    public class A {
                      private B b;
                      public A(B b) {
                        this.b = b;
                      }
                    }
                    或者
                    public class A {
                      private B b;
                      public A() {
                        this.b = new B();
                      }
                    }    
                    
                依赖：
                    依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。
                    不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 
                    B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，
                    我们都称它们有依赖关系。具体到 Java 代码就是下面这样：
               
                    public class A {
                      private B b;
                      public A(B b) {
                        this.b = b;
                      }
                    }
                    或者
                    public class A {
                      private B b;
                      public A() {
                        this.b = new B();
                      }
                    }
                    或者
                    public class A {
                      public void func(B b) { ... }
                    }
            
            d. 将类组装起来并提供执行入口
                这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。
                通过这个入口，我们能触发整个代码跑起来。
                
    （4）接口 VS 抽象类
        
        抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。
        接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了
        解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。
        
        什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。
        如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；
        如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。
        
    
    （5）基于接口而非实现类
         应用这条原则，可以将接口和实现分离，封装不稳定实现，暴露稳定的接口。
         实际上，“基于接口而非实现编程”这条原则的另一个表述方式是，“基于抽象而非实现编程”。
         后者的表述方式其实更能体现这条原则的设计初衷。
         在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。
        
        越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。
        
    （6）多用组合少用继承
        
        继承主要有三个作用：表示 is-a 关系，支持多态性，代码复用。
        三个作用都可以通过组合、接口、委托三个技术手段来达成。
        除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。
        
        如何判断该用组合还是继承？
            如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。
            反之，我们就尽量使用组合来替代继承。
            除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。
    
    （7）贫血模式和充血模式
    
        贫血模式：面向过程，适合业务不复杂的系统开发
        充血模式：面向对象，适合业务复杂的系统开发
        两者区别在 Service层，Controller层和Repository层基本相同。
        
    
2、设计原则:

    （1）SOLID原则-SRP单一职责原则
        单一职责原则通过避免色设计大而全的类，避免将不相关的功能耦合在一起，提高内聚性。
        出现下面这些情况就有可能说明这类的设计不满足单一职责原则：
            类中的代码行数、函数或者属性过多；
            类依赖的其他类过多或者依赖类的其他类过多；
            私有方法过多；
            比较难给类起一个合适的名字；
            类中大量的方法都是集中操作类中的某几个属性。
            
    （2）SOLID原则-OCP开闭原则
        添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），
        而非修改已有代码（修改模块、类、方法、属性等）的方式来完成
    （3）SOLID原则-LSP里氏替换原则：
        子类对象（object of subtype/derived class）能够
        替换程序（program）中父类对象（object of base/parent class）出现的任何地方，
        并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。
        
        里式替换原则是用来指导继承关系中子类该如何设计的一个原则。
        理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。
        父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，
        但不能改变函数的原有“约定”。这里的“约定”包括：函数声明要实现的功能；
        对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
        理解这个原则，我们还要弄明白，里式替换原则跟多态的区别。
        虽然从定义描述和代码实现上来看，多态和里式替换有点类似，
        但它们关注的角度是不一样的。多态是面向对象编程的一大特性，
        也是面向对象编程语言的一种语法。它是一种代码实现的思路。
        而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，
        子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。
        
      
    （4）SOLID原则-LSP接口隔开原则
    （5）SOLID原则-DIP依赖倒置原则
    （6）DRY原则
    （7）KISS原则
    （8）YANGI原则
    （9）LOD原则 迪米特法则
    
    SOLID、DRY、KISS、YAGNI、LOD等
            SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是：
            单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，
            依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母。
        
        KISS 原则：尽量保持简单
            Keep It Simple and Stupid.
            Keep It Short and Simple.
            Keep It Simple and Straightforward.
        
        YANGI: 不要过度设计
            YAGNI 原则的英文全称是：You Ain’t Gonna Need It。
            直译就是：你不会需要它。这条原则也算是万金油了。
            当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；
            不要去编写当前用不到的代码。
            实际上，这条原则的核心思想就是：不要做过度设计。    
        
        DRY 原则（Don’t Repeat Yourself）: 不要重复
            实现逻辑重复、功能语义重复和代码执行重复。
    
        LOD迪米特法则实现：最小知识原则
            Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。
            不过，它还有另外一个更加达意的名字，叫作最小知识原则，
            英文翻译为：The Least Knowledge Principle。
        
3、规范:

    （1）关于命名：
        
        命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。
        作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。
        除此之外，命名中也可以使用一些耳熟能详的缩写。
        
        我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。
        
        命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。
        除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。
        
        接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。
        对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。
        这两种命名方式都可以，关键是要在项目中统一。     
       
    (2)关于注释：
        注释的目的就是让代码更容易看懂。
        只要符合这个要求的内容，你就可以将它写到注释里。
        总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。
        对于一些复杂的类和接口，我们可能还需要写明“如何用”。
        
        注释本身有一定的维护成本，所以并非越多越好。
        类和函数一定要写注释，而且要写的尽可能全面和详细，
        而函数内部的注释要相对少一些，一般都要靠好的命名、
        提炼函数、解释性变量、总结性注释来提高代码的可读性。
        
    （3）关于代码风格：
        函数、类多大才合适？函数的代码行数不要超过一屏幕的大小，比如 50 行。
        类的大小限制比较难确定。
        
        一行代码多长最合适？最好不要超过 IDE 的显示宽度。当然，也不能太小，
        否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。
        
        善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。
        
        四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，
        尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。
        
        大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。
        但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，
        更加一目了然。
        
        类中成员怎么排列？在 Google Java 编程规范中，依赖类按照字母序从小到大排列。
        类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，
        后写普通变量或函数，并且按照作用域大小依次排列。    
        
    （4） 关于编码技巧
        
        将复杂的逻辑提炼拆分成函数和类。
        
        通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。
        
        函数中不要使用参数来做代码执行逻辑的控制。
        
        函数设计要职责单一。
        
        移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，
        
        使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，
        
        将部分嵌套逻辑抽象成函数。
        
        用字面常量取代魔法数。
        
        用解释性变量来解释复杂表达式，以此提高代码可读性。
        
    （5）统一编码规范
        
        还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，
        并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。
    
4、重构：
    
    （1）目的、对象、时机、方法
    （2）单元测试和代码的可测试性
    （3）大重构（大规模高层次）
    （4）小重构（小规模低层次）    
    
 
5、设计模式:

    （1）创建性：
        创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
        常用：
            单例模式：
                创建全局唯一的对象
            工厂模式（工厂方法、抽像方法）：
                创建不同但是相关类型的对象(继承同一父类或者接口的一组子类)，有给定的参数来决定创建那种类型的对象。
            建造者模式：
                构建者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。
        不常用：
            原型模式：
                原型针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。       
    
    
    （2）结构性：
        结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典结构可以解决特定应用场景的问题。
    
        常用：
            代理模式：
                代理模式(Proxy Design Pattern)的原理和代码实现都不难掌握。它在不改变原始类(被代理类)
                代码的情况下，通过引入代理类来给原始类附加功能。
            
            桥接模式:
                
                桥接模式，也叫做桥梁模式，英文是 Bridge Design Pattern。
                对于这个模式有两种不同的理解方式。
                a、将抽象和实现解耦，让它们可以独立变化
                b、一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，
                    让这两个（或多个）维度可以独立进行扩展。”
                    通过组合关系来替代继承关系，避免继承层次的指数级爆炸。
                    这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则
                
            装饰器模式:
                装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。
                    它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。
                    除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。
                    为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。  
                
            适配器模式:
                适配器模式(Adapter Design Pattern) 就是用来做适配的，它将不兼容的接口转换为可兼容的接口
                让原本由于接口不兼容不能一起工作的类可以一起工作。
                适配器模式有两种实现方式：类适配器和对象适配器。
                其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。
        
        代理、桥接、装饰器、适配器 4 种设计模式的区别：
            代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。
            它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。
            
            尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。
            
            代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，
                    主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。        
            桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
            装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，
                      并且支持多个装饰器的嵌套使用。
            适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，
                    而代理模式、装饰器模式提供的都是跟原始类相同的接口。    
       
        不常用：
            门面模式:
                解决接口可复用性(通用性)和应用性直接的矛盾
                也叫外观模式，英文全称是 Faced Design Pattern。
                门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。  
                    
                这个定义很简洁，我再进一步解释一下。假设有一个系统 A，提供了 a、b、c、d 四个接口。
                系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。
                利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。
                
            组合模式
            亨元模式 :
                所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
                具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，
                在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。
                实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），
                提取出来设计成享元，让这些大量相似对象引用这些享元。    
               
               2. 享元模式的实现享元模式的代码实现非常简单，
                    主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，
                    以达到复用的目的。
    （3）行为型        
        常用：
            观察者模式
            模板模式
            策略模式
            职责链模式
            迭代器模式
            状态模式
        不常用：
            访问者模式
            备忘录模式
            命令模式
            解释器模式
            中介模式
            

    
                    
            
            
            