0、代码质量评判标准
      
      常用的几个标准：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。
      其中，可维护性、可读性、可扩展性最重要的三个标准。
      
   如何写出高质量的代码：
   
      写出高质量的代码需要掌握更加细化、更加落地的编程方法论,
      包含面向对象设计思想、设计原则、设计模式、编程规范、重构技巧等。       

1、面向对象:

    （1）封装、抽象、继承、多态
        
        封装：
            封装叫做信息隐藏或者数据访问保护，类通过暴露有限的访问接口，
            授权外部仅能通过类提供的方法来访问内部信息或数据。它需要编程语言
            提供权限访问控制语法来支持。java：private、protected、piblic。
            封装特性存在的意义，一方面是保护数据不被随意修改，提供代码的可维护性；
            另一方面是仅暴露有限的必要接口，提供类的易用性。
        
        抽象：
            如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，
            让使用者只需要关心方法提供了那些功能，不需要知道这些功能是如何实现的。
            抽象可以通过接口类或者抽象类来实现。
            抽象存在的意义，一方面是修改实现不需要改变定义；
            另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
        
        继承：
            继承用来表示类之间的 is-a 关。
            
        多态：
            多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。
            多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、
            duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、
            设计原则、编程技巧的代码实现基础。
                
    （2）面向对象编程 VS 面向过程编程：
        
        面向对象编程相比面向过程编程的优势主要有三个：
            a. 程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。
               面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
               
            b. 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。
               利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
               
            c. 从编程语言跟机器打交道方式的演进规律中，我们可以总结出：
                面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。

    （3）面向对象分析、设计、编程
        
        OOA: 面向对象分析，搞清楚做什么，产出是详细的需求描述，
        OOD: 面向对象设计，高清楚怎么做，产出是类。
        OOP: 面向对象编程，讲分析和设计的结果编译成代码的过程。
        
        面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。
        至于到底选择哪种划分方法，判定的标准是让代码尽量的满足“松耦合、高内聚”、
        单一职责、对扩展开放，对修改关闭。尽量地做到代码可复用、易读、易扩展、易维护。
        
        我们将需求描述转化为具体的类设计，这个环节可以拆分下面四部分：
            a. 划分职责进而识别出有那些类
                根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看那些
                功能点职责相近，操作同样的属性，可否归为同一个类。
                
            b. 定义类及其属性和方法：
              
                我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，
                把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。
            
            c. 定义类与类之间的交互关系
                
                泛化：
                    泛化（Generalization）可以简单理解为继承关系。
                    
                    public class A { ... }
                    public class B extends A { ... }
                    
                实现：
                    
                    实现（Realization）一般是指接口和实现类之间的关系。
                    
                    public interface A {...}
                    public class B implements A { ... }
                       
                组合：
                    组合、关联
                    组合（Composition）也是一种包含关系。A 类对象包含 B 类对象，
                    B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，
                    比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样
                    
                    public class A {
                      private B b;
                      public A() {
                        this.b = new B();
                      }
                    }
                    
                    关联（Association）是一种非常弱的关系，包含聚合、组合两种关系。
                    具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。
                    具体到 Java 代码就是下面这样：
                    
                    public class A {
                      private B b;
                      public A(B b) {
                        this.b = b;
                      }
                    }
                    或者
                    public class A {
                      private B b;
                      public A() {
                        this.b = new B();
                      }
                    }    
                    
                依赖：
                    依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。
                    不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 
                    B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，
                    我们都称它们有依赖关系。具体到 Java 代码就是下面这样：
               
                    public class A {
                      private B b;
                      public A(B b) {
                        this.b = b;
                      }
                    }
                    或者
                    public class A {
                      private B b;
                      public A() {
                        this.b = new B();
                      }
                    }
                    或者
                    public class A {
                      public void func(B b) { ... }
                    }
            
            d. 将类组装起来并提供执行入口
                这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。
                通过这个入口，我们能触发整个代码跑起来。
                
    （4）接口 VS 抽象类
    （5）基于接口而非实现类
    （6）多用组合少用继承
    （7）贫血模式和充血模式
    
        
    

2、设计原则:

    （1）SOLID原则-SRP单一职责原则
    （2）SOLID原则-OCP开闭原则
    （3）SOLID原则-LSP里氏替换原则
    （4）SOLID原则-LSP接口隔开原则
    （5）SOLID原则-DIP依赖倒置原则
    （6）DRY原则
    （7）KISS原则
    （8）YANGI原则
    （9）LOD原则 迪米特法则
    
    SOLID、DRY、KISS、YAGNI、LOD等
            SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是：
            单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，
            依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母。
        
        KISS 原则：尽量保持简单
            Keep It Simple and Stupid.
            Keep It Short and Simple.
            Keep It Simple and Straightforward.
        
        YANGI: 不要过度设计
            YAGNI 原则的英文全称是：You Ain’t Gonna Need It。
            直译就是：你不会需要它。这条原则也算是万金油了。
            当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；
            不要去编写当前用不到的代码。
            实际上，这条原则的核心思想就是：不要做过度设计。    
        
        DRY 原则（Don’t Repeat Yourself）: 不要重复
            实现逻辑重复、功能语义重复和代码执行重复。
    
        LOD迪米特法则实现：最小知识原则
            Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。
            不过，它还有另外一个更加达意的名字，叫作最小知识原则，
            英文翻译为：The Least Knowledge Principle。
        
3、规范:

    （1）关于命名：
        
        命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。
        作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。
        除此之外，命名中也可以使用一些耳熟能详的缩写。
        
        我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。
        
        命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。
        除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。
        
        接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。
        对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。
        这两种命名方式都可以，关键是要在项目中统一。     
       
    (2)关于注释：
        注释的目的就是让代码更容易看懂。
        只要符合这个要求的内容，你就可以将它写到注释里。
        总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。
        对于一些复杂的类和接口，我们可能还需要写明“如何用”。
        
        注释本身有一定的维护成本，所以并非越多越好。
        类和函数一定要写注释，而且要写的尽可能全面和详细，
        而函数内部的注释要相对少一些，一般都要靠好的命名、
        提炼函数、解释性变量、总结性注释来提高代码的可读性。
        
    （3）关于代码风格：
        函数、类多大才合适？函数的代码行数不要超过一屏幕的大小，比如 50 行。
        类的大小限制比较难确定。
        
        一行代码多长最合适？最好不要超过 IDE 的显示宽度。当然，也不能太小，
        否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。
        
        善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。
        
        四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，
        尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。
        
        大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。
        但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，
        更加一目了然。
        
        类中成员怎么排列？在 Google Java 编程规范中，依赖类按照字母序从小到大排列。
        类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，
        后写普通变量或函数，并且按照作用域大小依次排列。    
        
    （4） 关于编码技巧
        
        将复杂的逻辑提炼拆分成函数和类。
        
        通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。
        
        函数中不要使用参数来做代码执行逻辑的控制。
        
        函数设计要职责单一。
        
        移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，
        
        使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，
        
        将部分嵌套逻辑抽象成函数。
        
        用字面常量取代魔法数。
        
        用解释性变量来解释复杂表达式，以此提高代码可读性。
        
    （5）统一编码规范
        
        还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，
        并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。
    
4、重构：
    
    （1）目的、对象、时机、方法
    （2）单元测试和代码的可测试性
    （3）大重构（大规模高层次）
    （4）小重构（小规模低层次）    
    
 
5、设计模式:

    （1）创建性：
        常用：
            单例模式
            工厂模式（工厂方法、抽像方法）
            建造者模式
        
        不常用：
            原型模式       
    （2）结构性
        常用：
            代理模式
            桥接模式
            装饰器模式
            适配器模式
        不常用：
            门面模式
            组合模式
            亨元模式    
    （3）行为型        
        常用：
            观察者模式
            模板模式
            策略模式
            职责链模式
            迭代器模式
            状态模式
        不常用：
            访问者模式
            备忘录模式
            命令模式
            解释器模式
            中介模式
            

    
                    
            
            
            