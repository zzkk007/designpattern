
1、建造者模式：详细构件函数、set方法、建造者模式三种对象创建方式

    创建型设计模式，Builder 模式，译为建造者模式或者构建模式、也有人叫它生成器模式。
    
2、为什么需要建造者模式：

    平时开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。    
    什么情况下这种方式不适应，需要采用建造者模式来创建对象。
    
    通过构造函数设置必选项，通过set()方法设置可选项配置。满足创建对象。
    如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。
        
        a、我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。
           如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。
           如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。 
        
        b、除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 
           其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，
           比如，maxIdle 和 minIdle 要小于等于 maxTotal。
           如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。
        
        c、如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，
           就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。   
    
    为了解决这些问题，建造者模式就派上用场了。
    
        我们可以把校验逻辑放置到Builder类中，先创建构建者，并且通过set()方法设置构造者的变量值，然后在使用
        builder() 方法真正创建对象之前，做集中的校验，校验通过之后才创建对象。
        除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。
        这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。
        并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。       
        
    实际上，使用建造者模式创建对象，还能避免对象存在无效状态。
    我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，
    那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示：
                 
        Rectangle r = new Rectange(); // r is invalid
        r.setWidth(2); // r is invalid
        r.setHeight(3); // r is valid    
    
    为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。
    如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，
    让对象一直处于有效状态。
    
    实际上，如果我们并不是很关心对象是否有短暂的无效状态，
    也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，
    那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。
    而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，
    要在 Builder 类中重新再定义一遍。
    
3、创建者模式和工厂模式有何区别？

    建造者模式是让建造者类来负责对象的创建工作。工厂类来负责对象创建的工作。那它们之间有什么区别呢？
   
    实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），
    由给定的参数来决定创建哪种类型的对象。 
    建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。
    
        